/**
 Copyright (c) 2015-present, Facebook, Inc.
 All rights reserved.

 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
 */

/*
 * This is a modified version of libc++'s <experimental/optional> with its dependency
 * on libc++-specific defines and includes removed to be usable with all C++11 compilers.
 * It also moves it from namespace std to namespace ext to not conflict with the real one.
 */

// -*- C++ -*-
//===-------------------------- optional ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _EXT_OPTIONAL
#define _EXT_OPTIONAL

/*
    optional synopsis

// C++1y

namespace std { namespace experimental { inline namespace fundamentals_v1 {

    // 5.3, optional for object types
    template <class T> class optional;

    // 5.4, In-place construction
    struct in_place_t{};
    constexpr in_place_t in_place{};

    // 5.5, No-value state indicator
    struct nullopt_t{see below};
    constexpr nullopt_t nullopt(unspecified);

    // 5.6, Class bad_optional_access
    class bad_optional_access;

    // 5.7, Relational operators
    template <class T>
      constexpr bool operator==(const optional<T>&, const optional<T>&);
    template <class T>
      constexpr bool operator!=(const optional<T>&, const optional<T>&);
    template <class T>
      constexpr bool operator<(const optional<T>&, const optional<T>&);
    template <class T>
      constexpr bool operator>(const optional<T>&, const optional<T>&);
    template <class T>
      constexpr bool operator<=(const optional<T>&, const optional<T>&);
    template <class T>
      constexpr bool operator>=(const optional<T>&, const optional<T>&);

    // 5.8, Comparison with nullopt
    template <class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
    template <class T> constexpr bool operator==(nullopt_t, const optional<T>&) noexcept;
    template <class T> constexpr bool operator!=(const optional<T>&, nullopt_t) noexcept;
    template <class T> constexpr bool operator!=(nullopt_t, const optional<T>&) noexcept;
    template <class T> constexpr bool operator<(const optional<T>&, nullopt_t) noexcept;
    template <class T> constexpr bool operator<(nullopt_t, const optional<T>&) noexcept;
    template <class T> constexpr bool operator<=(const optional<T>&, nullopt_t) noexcept;
    template <class T> constexpr bool operator<=(nullopt_t, const optional<T>&) noexcept;
    template <class T> constexpr bool operator>(const optional<T>&, nullopt_t) noexcept;
    template <class T> constexpr bool operator>(nullopt_t, const optional<T>&) noexcept;
    template <class T> constexpr bool operator>=(const optional<T>&, nullopt_t) noexcept;
    template <class T> constexpr bool operator>=(nullopt_t, const optional<T>&) noexcept;

    // 5.9, Comparison with T
    template <class T> constexpr bool operator==(const optional<T>&, const T&);
    template <class T> constexpr bool operator==(const T&, const optional<T>&);
    template <class T> constexpr bool operator!=(const optional<T>&, const T&);
    template <class T> constexpr bool operator!=(const T&, const optional<T>&);
    template <class T> constexpr bool operator<(const optional<T>&, const T&);
    template <class T> constexpr bool operator<(const T&, const optional<T>&);
    template <class T> constexpr bool operator<=(const optional<T>&, const T&);
    template <class T> constexpr bool operator<=(const T&, const optional<T>&);
    template <class T> constexpr bool operator>(const optional<T>&, const T&);
    template <class T> constexpr bool operator>(const T&, const optional<T>&);
    template <class T> constexpr bool operator>=(const optional<T>&, const T&);
    template <class T> constexpr bool operator>=(const T&, const optional<T>&);

    // 5.10, Specialized algorithms
    template <class T> void swap(optional<T>&, optional<T>&) noexcept(see below);
    template <class T> constexpr optional<see below> make_optional(T&&);

	template <class T>
	class optional
	{
	public:
	  typedef T value_type;

	  // 5.3.1, Constructors
	  constexpr optional() noexcept;
	  constexpr optional(nullopt_t) noexcept;
	  optional(const optional&);
	  optional(optional&&) noexcept(see below);
	  constexpr optional(const T&);
	  constexpr optional(T&&);
	  template <class... Args> constexpr explicit optional(in_place_t, Args&&...);
	  template <class U, class... Args>
		constexpr explicit optional(in_place_t, initializer_list<U>, Args&&...);

	  // 5.3.2, Destructor
	  ~optional();

	  // 5.3.3, Assignment
	  optional& operator=(nullopt_t) noexcept;
	  optional& operator=(const optional&);
	  optional& operator=(optional&&) noexcept(see below);
	  template <class U> optional& operator=(U&&);
	  template <class... Args> void emplace(Args&&...);
	  template <class U, class... Args>
		void emplace(initializer_list<U>, Args&&...);

	  // 5.3.4, Swap
	  void swap(optional&) noexcept(see below);

	  // 5.3.5, Observers
	  constexpr T const* operator ->() const;
	  constexpr T* operator ->();
	  constexpr T const& operator *() const &;
	  constexpr T& operator *() &;
	  constexpr T&& operator *() &&;
	  constexpr const T&& operator *() const &&;
	  constexpr explicit operator bool() const noexcept;
	  constexpr T const& value() const &;
	  constexpr T& value() &;
	  constexpr T&& value() &&;
	  constexpr const T&& value() const &&;
	  template <class U> constexpr T value_or(U&&) const &;
	  template <class U> constexpr T value_or(U&&) &&;

	private:
	  T*   val;  // exposition only
	};

  } // namespace fundamentals_v1
  } // namespace experimental

  // 5.11, Hash support
  template <class T> struct hash;
  template <class T> struct hash<experimental::optional<T>>;

} // namespace std

*/

#include <functional>
#include <stdexcept>

#if defined(__clang__)
#if !(__has_feature(cxx_exceptions))
#define _EXT_NO_EXCEPTIONS
#endif
#elif defined(__GNUC__)
#if !__EXCEPTIONS
#define _EXT_NO_EXCEPTIONS
#endif
#endif

#if defined(__clang__) || defined(__GNUC__)
#define _EXT_ALWAYS_INLINE __attribute__ ((__always_inline__))
#define _EXT_DEFAULT_VISIBILITY __attribute__ ((__visibility__("default")))
#else
#define _EXT_ALWAYS_INLINE
#define _EXT_DEFAULT_VISIBILITY
#endif

namespace ext {

template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp>
struct __has_operator_addressof_member_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(std::declval<_Up>().operator&()), std::true_type>::type;
    template <class>
        static auto __test(long) -> std::false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof_free_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(operator&(std::declval<_Up>())), std::true_type>::type;
    template <class>
        static auto __test(long) -> std::false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public std::integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};

struct __nat
{
    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;
};

struct __any
{
    __any(...);
};

namespace __detail
{

using std::swap;
__nat swap(__any, __any);

template <class _Tp>
struct __swappable
{
    typedef decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>())) type;
    static const bool value = !std::is_same<type, __nat>::value;
};

}  // __detail

template <class _Tp>
struct __is_swappable
    : public std::integral_constant<bool, __detail::__swappable<_Tp>::value>
{
};

template <bool, class _Tp>
struct __is_nothrow_swappable_imp
    : public std::true_type
{
};

template <class _Tp>
struct __is_nothrow_swappable_imp<false, _Tp>
    : public std::false_type
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>
{
};

}

namespace ext {
class bad_optional_access
    : public std::logic_error
{
public:
	bad_optional_access() : std::logic_error("Bad optional Access") {}

//	Get the key function ~bad_optional_access() into the dylib
    virtual ~bad_optional_access() noexcept;
};

}


#include <initializer_list>
#include <type_traits>
#include <new>

namespace ext {

struct in_place_t {};
constexpr in_place_t in_place{};

struct nullopt_t
{
    explicit constexpr nullopt_t(int) noexcept {}
};

constexpr nullopt_t nullopt{0};

template <class _Tp, bool = std::is_trivially_destructible<_Tp>::value>
class __optional_storage
{
protected:
    typedef _Tp value_type;
    union
    {
        char __null_state_;
        value_type __val_;
    };
    bool __engaged_ = false;

    _EXT_ALWAYS_INLINE
    ~__optional_storage()
    {
        if (__engaged_)
            __val_.~value_type();
    }

    _EXT_ALWAYS_INLINE
    constexpr __optional_storage() noexcept
        :  __null_state_('\0') {}

    _EXT_ALWAYS_INLINE
    __optional_storage(const __optional_storage& __x)
        :  __engaged_(__x.__engaged_)
        {
            if (__engaged_)
                ::new(std::addressof(__val_)) value_type(__x.__val_);
        }

    _EXT_ALWAYS_INLINE
    __optional_storage(__optional_storage&& __x)
                      noexcept(std::is_nothrow_move_constructible<value_type>::value)
        :  __engaged_(__x.__engaged_)
        {
            if (__engaged_)
                ::new(std::addressof(__val_)) value_type(std::move(__x.__val_));
        }

    _EXT_ALWAYS_INLINE
    constexpr __optional_storage(const value_type& __v)
        :  __val_(__v),
           __engaged_(true) {}

    _EXT_ALWAYS_INLINE
    constexpr __optional_storage(value_type&& __v)
        :  __val_(std::move(__v)),
           __engaged_(true) {}

    template <class... _Args>
    _EXT_ALWAYS_INLINE
    constexpr
    explicit __optional_storage(in_place_t, _Args&&... __args)
       :  __val_(std::forward<_Args>(__args)...),
           __engaged_(true) {}
};

template <class _Tp>
class __optional_storage<_Tp, true>
{
protected:
    typedef _Tp value_type;
    union
    {
        char __null_state_;
        value_type __val_;
    };
    bool __engaged_ = false;

    _EXT_ALWAYS_INLINE
    constexpr __optional_storage() noexcept
        :  __null_state_('\0') {}

    _EXT_ALWAYS_INLINE
    __optional_storage(const __optional_storage& __x)
        :  __engaged_(__x.__engaged_)
        {
            if (__engaged_)
                ::new(std::addressof(__val_)) value_type(__x.__val_);
        }

    _EXT_ALWAYS_INLINE
    __optional_storage(__optional_storage&& __x)
                      noexcept(std::is_nothrow_move_constructible<value_type>::value)
        :  __engaged_(__x.__engaged_)
        {
            if (__engaged_)
                ::new(std::addressof(__val_)) value_type(std::move(__x.__val_));
        }

    _EXT_ALWAYS_INLINE
    constexpr __optional_storage(const value_type& __v)
        :  __val_(__v),
           __engaged_(true) {}

    _EXT_ALWAYS_INLINE
    constexpr __optional_storage(value_type&& __v)
        :  __val_(std::move(__v)),
           __engaged_(true) {}

    template <class... _Args>
    _EXT_ALWAYS_INLINE
    constexpr
    explicit __optional_storage(in_place_t, _Args&&... __args)
       :  __val_(std::forward<_Args>(__args)...),
           __engaged_(true) {}
};

template <class _Tp>
class optional
    : private __optional_storage<_Tp>
{
    typedef __optional_storage<_Tp> __base;
public:
    typedef _Tp value_type;

    static_assert(!std::is_reference<value_type>::value,
              "Instantiation of optional with a reference type is ill-formed.");
    static_assert(!std::is_same<typename std::remove_cv<value_type>::type, in_place_t>::value,
              "Instantiation of optional with a in_place_t type is ill-formed.");
    static_assert(!std::is_same<typename std::remove_cv<value_type>::type, nullopt_t>::value,
              "Instantiation of optional with a nullopt_t type is ill-formed.");
    static_assert(std::is_object<value_type>::value,
        "Instantiation of optional with a non-object type is undefined behavior.");
    static_assert(std::is_nothrow_destructible<value_type>::value,
        "Instantiation of optional with an object type that is not noexcept destructible is undefined behavior.");

    _EXT_ALWAYS_INLINE constexpr optional() noexcept {}
    _EXT_ALWAYS_INLINE optional(const optional&) = default;
    _EXT_ALWAYS_INLINE optional(optional&&) = default;
    _EXT_ALWAYS_INLINE ~optional() = default;
    _EXT_ALWAYS_INLINE constexpr optional(nullopt_t) noexcept {}
    _EXT_ALWAYS_INLINE constexpr optional(const value_type& __v)
        : __base(__v) {}
    _EXT_ALWAYS_INLINE constexpr optional(value_type&& __v)
        : __base(std::move(__v)) {}

    template <class... _Args,
              class = typename std::enable_if
                      <
                           std::is_constructible<value_type, _Args...>::value
                      >::type
             >
    _EXT_ALWAYS_INLINE
    constexpr
    explicit optional(in_place_t, _Args&&... __args)
        : __base(in_place, std::forward<_Args>(__args)...) {}

    template <class _Up, class... _Args,
              class = typename std::enable_if
                      <
                           std::is_constructible<value_type, std::initializer_list<_Up>&, _Args...>::value
                      >::type
             >
    _EXT_ALWAYS_INLINE
    constexpr
    explicit optional(in_place_t, std::initializer_list<_Up> __il, _Args&&... __args)
        : __base(in_place, __il, std::forward<_Args>(__args)...) {}

    _EXT_ALWAYS_INLINE
    optional& operator=(nullopt_t) noexcept
    {
        if (this->__engaged_)
        {
            this->__val_.~value_type();
            this->__engaged_ = false;
        }
        return *this;
    }

    _EXT_ALWAYS_INLINE
    optional&
    operator=(const optional& __opt)
    {
        if (this->__engaged_ == __opt.__engaged_)
        {
            if (this->__engaged_)
                this->__val_ = __opt.__val_;
        }
        else
        {
            if (this->__engaged_)
                this->__val_.~value_type();
            else
                ::new(std::addressof(this->__val_)) value_type(__opt.__val_);
            this->__engaged_ = __opt.__engaged_;
        }
        return *this;
    }

    _EXT_ALWAYS_INLINE
    optional&
    operator=(optional&& __opt)
        noexcept(std::is_nothrow_move_assignable<value_type>::value &&
                 std::is_nothrow_move_constructible<value_type>::value)
    {
        if (this->__engaged_ == __opt.__engaged_)
        {
            if (this->__engaged_)
                this->__val_ = std::move(__opt.__val_);
        }
        else
        {
            if (this->__engaged_)
                this->__val_.~value_type();
            else
                ::new(std::addressof(this->__val_)) value_type(std::move(__opt.__val_));
            this->__engaged_ = __opt.__engaged_;
        }
        return *this;
    }

    template <class _Up,
              class = typename std::enable_if
                      <
                          std::is_same<typename std::remove_reference<_Up>::type, value_type>::value &&
                          std::is_constructible<value_type, _Up>::value &&
                          std::is_assignable<value_type&, _Up>::value
                      >::type
             >
    _EXT_ALWAYS_INLINE
    optional&
    operator=(_Up&& __v)
    {
        if (this->__engaged_)
            this->__val_ = std::forward<_Up>(__v);
        else
        {
            ::new(std::addressof(this->__val_)) value_type(std::forward<_Up>(__v));
            this->__engaged_ = true;
        }
        return *this;
    }

    template <class... _Args,
              class = typename std::enable_if
                      <
                          std::is_constructible<value_type, _Args...>::value
                      >::type
             >
    _EXT_ALWAYS_INLINE
    void
    emplace(_Args&&... __args)
    {
        *this = nullopt;
        ::new(std::addressof(this->__val_)) value_type(std::forward<_Args>(__args)...);
        this->__engaged_ = true;
    }

    template <class _Up, class... _Args,
              class = typename std::enable_if
                      <
                          std::is_constructible<value_type, std::initializer_list<_Up>&, _Args...>::value
                      >::type
             >
    _EXT_ALWAYS_INLINE
    void
    emplace(std::initializer_list<_Up> __il, _Args&&... __args)
    {
        *this = nullopt;
        ::new(std::addressof(this->__val_)) value_type(__il, std::forward<_Args>(__args)...);
        this->__engaged_ = true;
    }

    _EXT_ALWAYS_INLINE
    void
    swap(optional& __opt)
        noexcept(std::is_nothrow_move_constructible<value_type>::value &&
                 __is_nothrow_swappable<value_type>::value)
    {
        using std::swap;
        if (this->__engaged_ == __opt.__engaged_)
        {
            if (this->__engaged_)
                swap(this->__val_, __opt.__val_);
        }
        else
        {
            if (this->__engaged_)
            {
                ::new(std::addressof(__opt.__val_)) value_type(std::move(this->__val_));
                this->__val_.~value_type();
            }
            else
            {
                ::new(std::addressof(this->__val_)) value_type(std::move(__opt.__val_));
                __opt.__val_.~value_type();
            }
            swap(this->__engaged_, __opt.__engaged_);
        }
    }

    _EXT_ALWAYS_INLINE
    constexpr
    value_type const*
    operator->() const
    {
        // ASSERT(this->__engaged_, "optional operator-> called for disengaged value");
        return __operator_arrow(__has_operator_addressof<value_type>{});
    }

    _EXT_ALWAYS_INLINE
    value_type*
    operator->()
    {
        // ASSERT(this->__engaged_, "optional operator-> called for disengaged value");
        return std::addressof(this->__val_);
    }

    _EXT_ALWAYS_INLINE
    constexpr
    const value_type&
    operator*() const
    {
        // ASSERT(this->__engaged_, "optional operator* called for disengaged value");
        return this->__val_;
    }

    _EXT_ALWAYS_INLINE
    value_type&
    operator*()
    {
        // ASSERT(this->__engaged_, "optional operator* called for disengaged value");
        return this->__val_;
    }

    _EXT_ALWAYS_INLINE
    constexpr explicit operator bool() const noexcept {return this->__engaged_;}

    _EXT_ALWAYS_INLINE
    constexpr value_type const& value() const
    {
        return (!this->__engaged_) ?
#if !defined(_EXT_NO_EXCEPTIONS)
            throw bad_optional_access() :
#else
            abort() :
#endif
        this->__val_;
    }

    _EXT_ALWAYS_INLINE
    value_type& value()
    {
        return (!this->__engaged_) ?
#if !defined(_EXT_NO_EXCEPTIONS)
            throw bad_optional_access() :
#else
            abort() :
#endif
        this->__val_;
    }

    template <class _Up>
    _EXT_ALWAYS_INLINE
    constexpr value_type value_or(_Up&& __v) const&
    {
        static_assert(std::is_copy_constructible<value_type>::value,
                      "optional<T>::value_or: T must be copy constructible");
        static_assert(std::is_convertible<_Up, value_type>::value,
                      "optional<T>::value_or: U must be convertible to T");
        return this->__engaged_ ? this->__val_ :
                                  static_cast<value_type>(std::forward<_Up>(__v));
    }

    template <class _Up>
    _EXT_ALWAYS_INLINE
    value_type value_or(_Up&& __v) &&
    {
        static_assert(std::is_move_constructible<value_type>::value,
                      "optional<T>::value_or: T must be move constructible");
        static_assert(std::is_convertible<_Up, value_type>::value,
                      "optional<T>::value_or: U must be convertible to T");
        return this->__engaged_ ? std::move(this->__val_) :
                                  static_cast<value_type>(std::forward<_Up>(__v));
    }

private:
    _EXT_ALWAYS_INLINE
    value_type const*
    __operator_arrow(std::true_type) const
    {
        return std::addressof(this->__val_);
    }

    _EXT_ALWAYS_INLINE
    constexpr
    value_type const*
    __operator_arrow(std::false_type) const
    {
        return &this->__val_;
    }
};

// Comparisons between optionals
template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator==(const optional<_Tp>& __x, const optional<_Tp>& __y)
{
    return (static_cast<bool>(__x) != static_cast<bool>(__y)) ?
        false :
    (!static_cast<bool>(__x)) ?
        true :
    *__x == *__y;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator!=(const optional<_Tp>& __x, const optional<_Tp>& __y)
{
    return !(__x == __y);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<(const optional<_Tp>& __x, const optional<_Tp>& __y)
{
    return (!static_cast<bool>(__y)) ?
        false :
    (!static_cast<bool>(__x)) ?
        true :
    *__x < *__y;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>(const optional<_Tp>& __x, const optional<_Tp>& __y)
{
    return __y < __x;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<=(const optional<_Tp>& __x, const optional<_Tp>& __y)
{
    return !(__y < __x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>=(const optional<_Tp>& __x, const optional<_Tp>& __y)
{
    return !(__x < __y);
}


// Comparisons with nullopt
template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator==(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator==(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator!=(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator!=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<(const optional<_Tp>&, nullopt_t) noexcept
{
    return false;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<=(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return true;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return false;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>=(const optional<_Tp>&, nullopt_t) noexcept
{
    return true;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return !static_cast<bool>(__x);
}

// Comparisons with T
template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator==(const optional<_Tp>& __x, const _Tp& __v)
{
    return static_cast<bool>(__x) ? *__x == __v : false;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator==(const _Tp& __v, const optional<_Tp>& __x)
{
    return static_cast<bool>(__x) ? *__x == __v : false;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator!=(const optional<_Tp>& __x, const _Tp& __v)
{
    return static_cast<bool>(__x) ? !(*__x == __v) : true;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator!=(const _Tp& __v, const optional<_Tp>& __x)
{
    return static_cast<bool>(__x) ? !(*__x == __v) : true;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<(const optional<_Tp>& __x, const _Tp& __v)
{
    return static_cast<bool>(__x) ? std::less<_Tp>{}(*__x, __v) : true;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<(const _Tp& __v, const optional<_Tp>& __x)
{
    return static_cast<bool>(__x) ? std::less<_Tp>{}(__v, *__x) : false;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<=(const optional<_Tp>& __x, const _Tp& __v)
{
    return !(__x > __v);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator<=(const _Tp& __v, const optional<_Tp>& __x)
{
    return !(__v > __x);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>(const optional<_Tp>& __x, const _Tp& __v)
{
    return static_cast<bool>(__x) ? __v < __x : false;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>(const _Tp& __v, const optional<_Tp>& __x)
{
    return static_cast<bool>(__x) ? __x < __v : true;
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>=(const optional<_Tp>& __x, const _Tp& __v)
{
    return !(__x < __v);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
bool
operator>=(const _Tp& __v, const optional<_Tp>& __x)
{
    return !(__v < __x);
}


template <class _Tp>
inline _EXT_ALWAYS_INLINE
void
swap(optional<_Tp>& __x, optional<_Tp>& __y) noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp>
inline _EXT_ALWAYS_INLINE
constexpr
optional<typename std::decay<_Tp>::type>
make_optional(_Tp&& __v)
{
    return optional<typename std::decay<_Tp>::type>(std::forward<_Tp>(__v));
}

}

namespace std {

template <class _Tp>
struct _EXT_DEFAULT_VISIBILITY hash<ext::optional<_Tp> >
{
    typedef ext::optional<_Tp> argument_type;
    typedef size_t        result_type;

    _EXT_ALWAYS_INLINE
    result_type operator()(const argument_type& __opt) const noexcept
    {
        return static_cast<bool>(__opt) ? hash<_Tp>()(*__opt) : 0;
    }
};

}

#endif  // _EXT_OPTIONAL
